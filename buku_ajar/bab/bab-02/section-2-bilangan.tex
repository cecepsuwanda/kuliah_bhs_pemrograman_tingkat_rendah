\section{Sistem Bilangan dan Representasi Data}

\subsection{Mengapa Sistem Bilangan Penting dalam Assembly?}

Dalam pemrograman assembly, pemahaman sistem bilangan sangat krusial karena \cite{wiki_binary_number}:
\begin{itemize}
  \item Komputer bekerja dengan sistem biner (0 dan 1)
  \item Alamat memori dan register dinyatakan dalam heksadesimal
  \item Debugging dan analisis kode memerlukan konversi antar sistem bilangan
  \item Optimasi memerlukan pemahaman representasi data di level bit
\end{itemize}

\subsection{Sistem Bilangan Dasar}

\subsubsection{Sistem Bilangan Biner (basis 2)}

Biner menggunakan dua digit (0 dan 1). Nilai tempatnya adalah pangkat 2: \(2^3, 2^2, 2^1, 2^0, \ldots\)

Contoh: \(101010_2 = 1\cdot 2^5 + 0\cdot 2^4 + 1\cdot 2^3 + 0\cdot 2^2 + 1\cdot 2^1 + 0\cdot 2^0 = 42_{10}\)

\subsubsection{Sistem Bilangan Heksadesimal (basis 16)}

Heksadesimal menggunakan digit 0--9 dan A--F (A=10, B=11, \ldots, F=15). Setiap digit heksadesimal memetakan tepat ke 4 bit (\textit{nibble}) \cite{wiki_hexadecimal}.

\begin{table}[H]
\centering
\caption{Tabel Konversi Sistem Bilangan}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Desimal} & \textbf{Biner} & \textbf{Heksadesimal} \\
\hline
0 & 0000 & 0 \\
1 & 0001 & 1 \\
2 & 0010 & 2 \\
3 & 0011 & 3 \\
4 & 0100 & 4 \\
5 & 0101 & 5 \\
6 & 0110 & 6 \\
7 & 0111 & 7 \\
8 & 1000 & 8 \\
9 & 1001 & 9 \\
10 & 1010 & A \\
11 & 1011 & B \\
12 & 1100 & C \\
13 & 1101 & D \\
14 & 1110 & E \\
15 & 1111 & F \\
\hline
\end{tabular}
\end{table}

\subsection{Konversi Antar Sistem Bilangan}

Metode konversi sistematis berikut sangat membantu dalam debugging dan analisis kode assembly \cite{wiki_binary_number}:

\subsubsection{Desimal ke Biner}
Gunakan metode pembagian berulang oleh 2 dan catat sisa pembagiannya. Urutan sisa dari bawah ke atas membentuk bilangan biner.

\begin{contoh}
\textbf{Konversi \(214_{10}\) ke biner:}

\begin{table}[H]
\centering
\caption{Konversi Desimal ke Biner}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Langkah} & \textbf{Operasi} & \textbf{Hasil Bagi} & \textbf{Sisa} \\
\hline
1 & 214 $\div$ 2 & 107 & 0 \\
2 & 107 $\div$ 2 & 53 & 1 \\
3 & 53 $\div$ 2 & 26 & 1 \\
4 & 26 $\div$ 2 & 13 & 0 \\
5 & 13 $\div$ 2 & 6 & 1 \\
6 & 6 $\div$ 2 & 3 & 0 \\
7 & 3 $\div$ 2 & 1 & 1 \\
8 & 1 $\div$ 2 & 0 & 1 \\
\hline
\end{tabular}
\end{table}

Membaca sisa dari bawah ke atas: \(11010110_2\). Jadi, \(214_{10} = 11010110_2\).
\end{contoh}

\subsubsection{Biner ke Desimal}
Kalikan setiap digit biner dengan \(2^{\text{posisi}}\) (posisi dimulai dari 0 di kanan), lalu jumlahkan.

\begin{contoh}
\textbf{Konversi \(11010110_2\) ke desimal:}

\begin{align*}
11010110_2 &= (1 \times 2^7) + (1 \times 2^6) + (0 \times 2^5) + (1 \times 2^4) + (0 \times 2^3) + (1 \times 2^2) + (1 \times 2^1) + (0 \times 2^0) \\
&= 128 + 64 + 0 + 16 + 0 + 4 + 2 + 0 = 214_{10}
\end{align*}
\end{contoh}

\subsubsection{Desimal ke Heksadesimal}
Metode pembagian berulang oleh 16. Jika sisa lebih dari 9, gunakan huruf A--F untuk 10--15.

\begin{contoh}
\textbf{Konversi \(255_{10}\) ke heksadesimal:}

\begin{table}[H]
\centering
\caption{Konversi Desimal ke Heksadesimal}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Langkah} & \textbf{Operasi} & \textbf{Hasil Bagi} & \textbf{Sisa} & \textbf{Representasi} \\
\hline
1 & 255 $\div$ 16 & 15 & 15 & F \\
2 & 15 $\div$ 16 & 0 & 15 & F \\
\hline
\end{tabular}
\end{table}

Membaca sisa dari bawah ke atas: \texttt{FF}h. Jadi, \(255_{10} = \mathrm{FF}_{16}\).
\end{contoh}

\subsubsection{Heksadesimal ke Biner dan Biner ke Heksadesimal}
Heksadesimal ke Biner: Setiap digit heksa = 4 bit biner (gunakan tabel di atas). Contoh: \(\mathrm{D6}_{16} = 1101\,0110_2\).

Biner ke Heksadesimal: Kelompokkan 4 bit dari kanan ke kiri, petakan ke digit heksa. Contoh: \(11010110_2 = 1101\,0110 = \mathrm{D6}_{16}\).

\subsection{Operasi Aritmatika Biner}

Operasi aritmatika biner fundamental untuk memahami perilaku ALU dan flag register (carry, overflow) dalam assembly \cite{wiki_binary_number}.

\subsubsection{Penjumlahan Biner}
Aturan dasar: \(0+0=0\), \(0+1=1\), \(1+1=10_2\) (tulis 0, simpan carry 1). Carry dari bit sebelumnya ditambahkan ke digit berikutnya.

\begin{contoh}
\textbf{Penjumlahan \(1011_2 + 1101_2\):}

\begin{tabular}{ccccc}
  & 1 & 0 & 1 & 1 \\
+ & 1 & 1 & 0 & 1 \\
\hline
1 & 1 & 0 & 0 & 0 \\
\end{tabular}

Langkah: \(1+1=10\) (carry 1), \(1+0+1=10\) (carry 1), \(0+1+1=10\) (carry 1), \(1+1+1=11\). Hasil: \(11000_2\) (11 + 13 = 24).
\end{contoh}

\subsubsection{Pengurangan Biner}
Aturan: \(0-0=0\), \(1-0=1\), \(1-1=0\), \(0-1=1\) (dengan \textit{borrow} dari posisi kiri). Borrow mempengaruhi flag CF (Carry Flag) pada instruksi SUB.

\begin{contoh}
\textbf{Pengurangan \(10010_2 - 01101_2\)} (18 - 13 = 5):

\begin{tabular}{cccccc}
1 & 0 & 0 & 1 & 0 & \\
- & 0 & 1 & 1 & 0 & 1 \\
\hline
  & 0 & 0 & 1 & 0 & 1 \\
\end{tabular}

Hasil: \(00101_2 = 5_{10}\).
\end{contoh}

\subsection{Representasi Data dalam Komputer}

\subsubsection{Satuan Data Dasar}

\begin{itemize}
  \item \textbf{Bit}: Unit terkecil, bernilai 0 atau 1
  \item \textbf{Byte}: 8 bit; satuan standar untuk karakter
  \item \textbf{Word}: Pada 8086, word = 16 bit (2 byte)
  \item \textbf{Double Word}: 32 bit (4 byte)
\end{itemize}

\subsubsection{Two's Complement (Bilangan Bertanda)}

Dalam assembly, instruksi seperti \asm{ADD}, \asm{SUB}, \asm{IMUL} bekerja dengan bilangan bertanda. Komputer merepresentasikan bilangan negatif dengan \textbf{Two's Complement} \cite{wiki_two_complement}:
\begin{enumerate}
  \item Tulis bilangan positif dalam biner
  \item Flip semua bit (0 jadi 1, 1 jadi 0)
  \item Tambahkan 1 ke hasilnya
\end{enumerate}

Contoh: \(-5\) dalam 8-bit:
\begin{itemize}
  \item \(+5 = 00000101\)
  \item Flip: \(11111010\)
  \item \(+1\): \(11111011\) = \(-5\)
\end{itemize}

\subsubsection{Endianness (Little-Endian pada 8086)}

Pemahaman endianness penting saat mengakses memori dengan \asm{MOV [addr], AX} atau saat debugging dengan TASM. \textbf{Little-Endian}: Byte LSB (Least Significant Byte) disimpan di alamat memori terkecil. Pada 8086, word \(0x1234\) disimpan sebagai: alamat 1000: 0x34, alamat 1001: 0x12 \cite{wiki_endianness}.

\subsubsection{Rentang Nilai}

\begin{table}[H]
\centering
\caption{Rentang nilai integer}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Ukuran} & \textbf{Unsigned} & \textbf{Signed (two's complement)} \\
\hline
8-bit & 0 -- 255 & $-128$ -- 127 \\
16-bit & 0 -- 65535 & $-32768$ -- 32767 \\
\hline
\end{tabular}
\end{table}

\subsection{Aplikasi Assembly}

Assembly language diterapkan dalam: embedded systems, bootloader, BIOS/UEFI, driver, kernel, keamanan siber, dan optimasi performa kritis.
