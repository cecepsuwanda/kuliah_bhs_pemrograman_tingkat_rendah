\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Pemrograman Grafik Dasar}

    \section{Tujuan Pembelajaran}
        Mahasiswa mampu:
        \begin{itemize}
            \item Menjelaskan perbedaan mode teks dan grafik, resolusi, palet warna, dan organisasi memori video.
            \item Menggunakan layanan BIOS \texttt{INT 10h} untuk mengatur mode grafik, menulis/membaca piksel, dan memeriksa mode aktif.
            \item Menggambar piksel dan garis di layar pada koordinat tertentu dengan warna yang dipilih.
            \item Mengimplementasikan algoritma garis (DDA/Bresenham) dan memahami trade-off kinerja/akurasi.
            \item Mengembangkan program grafik sederhana berbasis mode 13h (320x200x256) sebagai studi kasus.
        \end{itemize}

    \section{Pendahuluan}
        Mode grafik menyediakan akses piksel-tingkat ke layar, berbeda dengan mode teks yang berbasis karakter. Pada lingkungan DOS, BIOS menyediakan fungsi \texttt{INT 10h} untuk mengatur mode, menulis/membaca piksel, dan berbagai operasi tampilan. Mode 13h (320x200 dengan 256 warna) populer untuk pembelajaran karena memori video \textit{linear} (satu byte per piksel) yang mudah diakses. Materi ini ditempatkan setelah percabangan dan perulangan agar contoh dapat menggunakan kontrol alur yang tepat.

    \section{Konsep Mode Grafik}
        \subsection{Perbedaan mode teks dan grafik}
            Mode teks menampilkan karakter dari tabel font di layar, sedangkan mode grafik memetakan memori video langsung ke piksel. Mode teks lebih hemat memori dan sederhana; mode grafik memberi fleksibilitas menggambar bentuk bebas.

        \subsubsection{Resolusi layar dan palet}
            Resolusi menyatakan jumlah piksel horizontal x vertikal. Pada mode 13h: 320x200 piksel, 256 warna (palet 8-bit). Nilai warna \(0..255\) memetakan ke entri palet yang dapat diatur (di luar cakupan dasar ini).

        \subsubsection{Organisasi memori video dan pengalamatan piksel}
            Pada mode 13h, buffer video mulai di \texttt{A000:0000}. Offset piksel \((x,y)\) adalah \(y\cdot 320 + x\). Untuk mode lain (planar EGA/VGA), organisasi lebih kompleks.

        \subsection{Interupsi INT 10h untuk Grafik}
            \subsubsection{Fungsi 00h: Set Video Mode}
                \begin{itemize}
                    \item \textbf{Masukan}: \texttt{AH=00h}, \texttt{AL=mode} (\texttt{13h} untuk 320x200x256, \texttt{03h} kembali ke teks 80x25).
                    \item \textbf{Efek}: Mengatur mode tampilan dan membersihkan layar.
                \end{itemize}

            \subsubsection{Fungsi 0Ch: Write Pixel}
                \begin{itemize}
                    \item \textbf{Masukan}: \texttt{AH=0Ch}, \texttt{AL=color}, \texttt{BH=page}, \texttt{CX=x}, \texttt{DX=y}.
                    \item \textbf{Efek}: Menggambar piksel pada koordinat (x,y) dengan warna.
                \end{itemize}

            \subsubsection{Fungsi 0Dh: Read Pixel}
                \begin{itemize}
                    \item \textbf{Masukan}: \texttt{AH=0Dh}, \texttt{BH=page}, \texttt{CX=x}, \texttt{DX=y}.
                    \item \textbf{Keluaran}: \texttt{AL=color} pada piksel (x,y).
                \end{itemize}

            \subsubsection{Fungsi 0Fh: Get Video Mode}
                Mengembalikan mode saat ini, ukuran kolom, dan nomor halaman aktif.

        \subsection{Menggambar Piksel}
            \subsubsection{Koordinat dan warna}
                Koordinat (x,y) berbasis 0. Pastikan berada dalam batas resolusi. Untuk warna, pilih nilai palet \(0..255\).

            \subsubsection{Akses memori video langsung}
                Selain \texttt{INT 10h, 0Ch}, dapat menulis langsung ke \texttt{A000:0000 + y*320 + x} untuk kinerja. Pastikan \texttt{ES} menunjuk \texttt{A000h} dan gunakan \texttt{MOV} ke \texttt{ES:[DI]}/\texttt{ES:[BX]}.

            \subsubsection{Mode VGA 13h dan Palet}
                Pada mode 13h, satu byte merepresentasikan indeks palet (0..255). Pengaturan palet (DAC) dilakukan dengan port I/O VGA (di luar cakupan dasar ini), namun penting dipahami bahwa nilai piksel bukan RGB langsung.

            \subsubsection{Akses Langsung vs INT 10h}
                Pemanggilan \texttt{INT 10h} untuk setiap piksel bersifat mahal. Untuk kinerja tinggi, gunakan akses langsung ke memori video: muat \texttt{ES=A000h}, hitung offset \(y\cdot 320 + x\), lalu simpan byte warna. Gunakan \texttt{REP STOSB} untuk mengisi area.

            \subsubsection{Algoritma Garis: DDA vs Bresenham}
                DDA menggunakan penambahan pecahan dan pembulatan; sederhana namun lebih lambat. Bresenham memakai hanya integer, cocok untuk perangkat keras lama. Uji di emulator untuk melihat perbedaan jumlah instruksi.

            \subsubsection{Clipping Sederhana}
                Selalu periksa \(0 \le x < 320\) dan \(0 \le y < 200\) sebelum menulis. Untuk garis, lakukan \textit{trivial reject} ketika seluruh segmen di luar batas; untuk implementasi penuh, terapkan Cohenâ€“Sutherland (lanjutan).

        \subsection{Algoritma Menggambar Garis}
            \subsubsection{DDA (Digital Differential Analyzer)}
                Menginkremen koordinat dengan langkah pecahan. Mudah dipahami namun menggunakan operasi pecahan/float atau perkiraan \textit{fixed-point}; dapat lebih lambat.

            \subsubsection{Bresenham}
                Menggunakan aritmatika integer dan \textit{error term} untuk menentukan piksel berikutnya. Lebih efisien dan akurat untuk layar raster. Materi ini ditempatkan setelah percabangan dan perulangan agar contoh dapat menggunakan kontrol alur yang tepat.

            \subsubsection{Implementasi ringkas}
                \begin{verbatim}
; Pseudo: Bresenham integer
 dx = abs(x1-x0); dy = -abs(y1-y0)
 sx = x0<x1 ? 1 : -1
 sy = y0<y1 ? 1 : -1
 err = dx + dy
 while true:
   plot(x0,y0)
   if x0==x1 && y0==y1: break
   e2 = 2*err
   if e2 >= dy: err += dy; x0 += sx
   if e2 <= dx: err += dx; y0 += sy
                \end{verbatim}

        \subsection{Koordinat dan Transformasi}
            \subsubsection{Sistem koordinat}
                Asal (0,0) di pojok kiri atas; x ke kanan, y ke bawah. Transformasi translasi/skalasi dapat diterapkan sebelum penggambaran.

            \subsubsection{Clipping dan viewport}
                Batasi penggambaran dalam area tertentu untuk menghindari akses memori di luar layar. Sederhana: \textit{reject} jika di luar; lanjutkan jika di dalam.






\end{document}