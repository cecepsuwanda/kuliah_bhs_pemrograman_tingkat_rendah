\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Program Residen (TSR)}

    \section{Tujuan Pembelajaran}
        Mahasiswa mampu:
        \begin{itemize}
            \item Menjelaskan konsep \textit{Terminate-and-Stay-Resident} (TSR), arsitektur, dan pola penggunaannya di DOS.
            \item Mengimplementasikan TSR sederhana: inisialisasi, pemasangan handler interupsi, dan terminasi-residen.
            \item Menggunakan \texttt{INT 21h} fungsi \texttt{31h} (TSR), \texttt{25h}/\texttt{35h} (set/get interrupt vector) untuk komunikasi dan pemasangan.
            \item Mendesain mekanisme komunikasi (hotkey/custom interrupt) dan strategi manajemen memori TSR.
        \end{itemize}

    \section{Pendahuluan}
        Program TSR adalah program DOS yang, setelah selesai inisialisasi, tidak sepenuhnya keluar: sebagian memorinya dibiarkan \textit{resident} untuk memberikan layanan latar belakang (mis. hotkey, jam layar, makro). TSR lazim sebelum hadirnya sistem multitugas umum. Kunci teknis TSR adalah pemasangan handler interupsi/\textit{hook} dan pemilihan ukuran memori yang disisakan agar cukup namun tidak boros. Materi ini ditempatkan sebagai bab penutup karena memerlukan pemahaman mendalam tentang interupsi dan manajemen memori.

    \section{Konsep Program TSR}
        \subsection{Definisi dan perbedaan}
            Berbeda dengan program biasa yang mengembalikan seluruh memorinya saat \texttt{INT 21h, 4Ch}, TSR mengeksekusi \texttt{INT 21h, 31h} untuk mengakhiri eksekusi namun menyisakan bagian memori dan vektor interupsi yang terpasang.

        \subsubsection{Keuntungan dan kelemahan}
            \textbf{Keuntungan}: menyediakan layanan latar belakang, akses cepat (hotkey). \textbf{Kelemahan}: konflik vektor interupsi, fragmentasi memori, kompatibilitas antar TSR.

        \subsubsection{Aplikasi TSR}
            Jam layar, pengganti \textit{keyboard handler}, \textit{clipboard} sederhana, peluncur cepat, atau \textit{logging}.

        \subsubsection{Manajemen memori}
            Minimalkan memori resident dengan memindahkan data temporer ke tumpukan non-resident, lepaskan segmen yang tak diperlukan sebelum \texttt{INT 21h,31h}, dan hitung ukuran paragraf (16-byte) yang tepat.

        \subsection{Arsitektur Program TSR}
            \subsubsection{Inisialisasi}
                Deteksi apakah TSR sudah terpasang (misalnya melalui vector marker/custom call). Simpan vektor lama, pasang vektor baru, siapkan state minimal.

            \subsubsection{Resident routine dan interrupt handler}
                Rutinitas resident dijalankan oleh interupsi yang di-hook (mis. keyboard \texttt{INT 09h}, layanan \texttt{INT 21h}, timer \texttt{INT 1Ch}). Pastikan handler cepat, \textit{reentrant-safe} (seperlunya), dan memanggil handler lama bila tidak memproses sendiri.

            \subsubsection{Terminasi-residen}
                Panggil \texttt{INT 21h, AH=31h} dengan \texttt{DX} berisi ukuran memori yang dibiarkan resident (dalam paragraf). \texttt{AL} dapat mengembalikan kode keluar.

        \subsection{Interupsi untuk TSR}
            \subsubsection{Set/Get Interrupt Vector}
                \texttt{INT 21h, AH=35h} mendapatkan vektor (ke \texttt{ES:BX}); \texttt{AH=25h} memasang vektor baru dari \texttt{DS:DX}. Simpan vektor lama untuk pemulihan atau pemanggilan berantai (\textit{chain}).

            \subsubsection{Custom interrupt}
                TSR dapat mengekspos layanan melalui nomor interupsi khusus (jarang) atau \texttt{AH} khusus pada \texttt{INT 21h}. Penanda sederhana: jika \texttt{AH=FFh}, handler mengembalikan tanda di \texttt{AL}.

            \subsubsection{Reentransi dan Keamanan Handler}
                Handler TSR sering dipicu saat DOS/BIOS mungkin tidak reentrant. Hindari memanggil layanan DOS yang tidak aman dari interupsi di dalam handler; jika perlu, setel penanda dan lakukan pekerjaan berat di titik aman (mis. hook timer dan proses di luar handler sensitif). 
            \subsubsection{Perhitungan Ukuran Resident}
                Hitung total segmen yang perlu ditinggalkan resident (kode + data minimal). Ukur dalam paragraf (16 byte); tambahkan margin untuk variabel runtime. Lepaskan segmen yang tidak dibutuhkan (mis. tumpukan sementara) sebelum \texttt{INT 21h,31h}. 
            \subsubsection{Rantai Handler (Chaining)}
                Saat mengganti vektor, simpan vektor lama dan panggil jika event tidak ditangani agar kompatibel dengan TSR lain. Periksa kondisi untuk mencegah loop. Pastikan menyimpan/memulihkan register dengan benar. 
            \subsubsection{Deteksi Instalasi Ganda}
                Sediakan mekanisme \textit{self-detection} (mis. panggilan khusus yang mengembalikan tanda). Jika sudah terpasang, tawarkan keluar normal atau uninstall (bila aman). 
        \section{Implementasi TSR}
            \subsection{Struktur dan langkah}
                \begin{enumerate}
                    \item Cek instalasi: panggil layanan khusus; jika sudah, tawarkan uninstall atau keluar.
                    \item Simpan vektor lama; pasang handler baru (\texttt{25h}).
                    \item Siapkan data resident (variabel global minimal) dan lepaskan yang tidak diperlukan.
                    \item Panggil \texttt{31h} dengan estimasi ukuran memori resident.
                \end{enumerate}

            \subsection{Contoh Handler}
                \begin{verbatim}
; Handler INT 21h kustom: AH=FFh -> tanda aktif
NEW_INT21 PROC FAR
    CMP AH, 0FFh
    JNE CALL_OLD
    MOV AL, 0AAh
    IRET
CALL_OLD:
    JMP DWORD PTR old_int21
NEW_INT21 ENDP
                \end{verbatim}

            \subsection{Uninstall (opsional)}
                Uninstall yang bersih memerlukan restorasi vektor lama dan pembebasan memori (yang tidak mudah pada DOS standar). Banyak TSR tidak mendukung uninstall kecuali didesain khusus.






\end{document}