\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Instruksi Stack dan Subrutin}

    \section{Tujuan Pembelajaran}
        Mahasiswa mampu:
        \begin{itemize}
            \item Menjelaskan konsep tumpukan (stack), prinsip LIFO, serta peran \texttt{SS:SP}.
            \item Menggunakan instruksi \texttt{PUSH}/\texttt{POP} pada register dan memori dengan aman.
            \item Memanggil dan kembali dari subrutin menggunakan \texttt{CALL}/\texttt{RET} (near/far) dan memahami \textit{return address}.
            \item Mengirim parameter dan menerima nilai balik melalui register, stack, atau memori.
            \item Memodularisasi program menjadi prosedur-prosedur yang terpisah dan teruji.
        \end{itemize}

    \section{Pendahuluan}
        Stack adalah struktur data kritis untuk pengelolaan alur eksekusi dan data sementara \cite{tutorials_point_assembly}. Pada 8086, stack berada pada segmen \texttt{SS} dengan penunjuk \texttt{SP}. Instruksi \texttt{PUSH}/\texttt{POP} mengubah \texttt{SP} dan menyimpan/mengambil data 16-bit (atau 8-bit dipecah) dalam urutan LIFO \cite{8086_instruction_set_reference}. Instruksi \texttt{CALL}/\texttt{RET} mengandalkan stack untuk menyimpan alamat kembali ketika berpindah ke subrutin. Materi ini ditempatkan setelah percabangan dan perulangan agar contoh dapat menggunakan kontrol alur yang tepat.

    \section{Konsep Stack}
        \subsection{Dasar-dasar Stack}
            \subsubsection{Definisi dan prinsip LIFO}
                Stack adalah struktur data linear yang mengikuti prinsip \textbf{Last In, First Out (LIFO)}. Pada Intel 8086, stack tumbuh ke arah alamat memori yang lebih rendah. Ketika data di-\texttt{PUSH}, register \texttt{SP} (Stack Pointer) dikurangi terlebih dahulu, kemudian data disimpan di alamat yang ditunjuk oleh \texttt{SP}. Sebaliknya, ketika data di-\texttt{POP}, data dibaca dari alamat yang ditunjuk \texttt{SP}, kemudian \texttt{SP} dinaikkan.

                \begin{table}[H]
                    \centering
                    \caption{Karakteristik Stack Intel 8086}
                    \begin{tabular}{|p{3cm}|p{4cm}|p{6cm}|}
                        \hline
                        \textbf{Aspek} & \textbf{Spesifikasi} & \textbf{Keterangan} \\
                        \hline
                        \textbf{Arah Pertumbuhan} & Menurun (ke alamat rendah) & SP berkurang saat PUSH, bertambah saat POP \\
                        \hline
                        \textbf{Ukuran Operasi} & 16-bit (word) & Setiap operasi PUSH/POP memindahkan 2 byte \\
                        \hline
                        \textbf{Register} & SS:SP & SS = Stack Segment, SP = Stack Pointer \\
                        \hline
                        \textbf{Alamat Efektif} & SS Ã— 16 + SP & Alamat fisik untuk akses stack \\
                        \hline
                        \textbf{Ukuran Maksimal} & 64 KB & Batasan segmen stack \\
                        \hline
                    \end{tabular}
                    \label{tab:stack-characteristics}
                \end{table}

            \subsubsection{Register SS:SP dan layout memori}
                Pasangan \texttt{SS:SP} membentuk alamat efektif untuk operasi stack. Register \texttt{SS} (Stack Segment) menentukan segmen memori tempat stack berada, sedangkan \texttt{SP} (Stack Pointer) menunjuk ke lokasi puncak stack. 

                \textbf{Inisialisasi Stack:}
                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Inisialisasi Stack, label={lst:stack-init}]
; Inisialisasi stack segment dan pointer
mov ax, stack_segment    ; Load alamat segmen stack
mov ss, ax               ; Set stack segment
mov sp, stack_size       ; Set stack pointer ke ukuran stack
                \end{lstlisting}

                \textbf{Layout Memori Stack:}
                \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \textbf{Alamat Relatif} & \textbf{Konten} & \textbf{Keterangan} \\
                        \hline
                        SP + 2 & Data terakhir & Item yang akan di-POP \\
                        \hline
                        SP + 4 & Data kedua & Item berikutnya \\
                        \hline
                        SP + 6 & Data ketiga & Item berikutnya \\
                        \hline
                        ... & ... & ... \\
                        \hline
                        SP + n & Data pertama & Item yang pertama di-PUSH \\
                        \hline
                    \end{tabular}
                \end{center}

            \subsubsection{Operasi stack dalam assembly}
                Operasi dasar stack meliputi \texttt{PUSH} dan \texttt{POP} untuk data, serta \texttt{PUSHF}/\texttt{POPF} untuk register flags. Penting untuk menjaga keseimbangan stack dengan memastikan setiap \texttt{PUSH} memiliki \texttt{POP} yang sesuai.

                \textbf{Operasi PUSH:}
                \begin{enumerate}
                    \item SP = SP - 2 (kurangi stack pointer)
                    \item [SS:SP] = operand (simpan data di alamat yang ditunjuk SP)
                \end{enumerate}

                \textbf{Operasi POP:}
                \begin{enumerate}
                    \item operand = [SS:SP] (baca data dari alamat yang ditunjuk SP)
                    \item SP = SP + 2 (naikkan stack pointer)
                \end{enumerate}

        \subsection{Instruksi Stack}
            \subsubsection{PUSH/POP register}
                Instruksi \texttt{PUSH} dan \texttt{POP} dapat digunakan dengan register 16-bit. Urutan operasi harus diperhatikan karena stack mengikuti prinsip LIFO.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Operasi PUSH/POP Register, label={lst:push-pop-register}]
; Contoh operasi PUSH/POP register
push ax              ; Simpan AX ke stack
push bx              ; Simpan BX ke stack  
push cx              ; Simpan CX ke stack

; Akses data dari stack (urutan terbalik)
pop  cx              ; Ambil CX dari stack (data terakhir)
pop  bx              ; Ambil BX dari stack (data kedua)
pop  ax              ; Ambil AX dari stack (data pertama)

; Contoh penggunaan untuk pertukaran nilai
push ax              ; Simpan nilai AX
push bx              ; Simpan nilai BX
pop  ax              ; AX = nilai BX lama
pop  bx              ; BX = nilai AX lama
                \end{lstlisting}

                \textbf{Poin Penting:}
                \begin{itemize}
                    \item Urutan \texttt{POP} harus terbalik dari urutan \texttt{PUSH}
                    \item Setiap \texttt{PUSH} harus memiliki \texttt{POP} yang sesuai
                    \item Stack pointer (\texttt{SP}) berubah otomatis dengan setiap operasi
                \end{itemize}

            \subsubsection{PUSH/POP memori dan immediate}
                Beberapa assembler mendukung operasi stack dengan memori dan nilai langsung (immediate). Ini berguna untuk menyimpan/memulihkan data dari lokasi memori tertentu.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Operasi PUSH/POP Memori, label={lst:push-pop-memory}]
; Contoh operasi dengan memori
push word ptr [1000h]    ; Push nilai dari alamat 1000h
push 1234h               ; Push nilai langsung 1234h
push [bx]                ; Push nilai dari alamat yang ditunjuk BX

; Pop ke memori
pop  word ptr [2000h]    ; Pop ke alamat 2000h
pop  [si]                ; Pop ke alamat yang ditunjuk SI

; Contoh penggunaan dalam prosedur
push word ptr [bp+4]     ; Push parameter dari stack frame
pop  ax                  ; Ambil parameter ke AX
                \end{lstlisting}

                \textbf{Keterbatasan:}
                \begin{itemize}
                    \item Tidak semua assembler mendukung \texttt{PUSH immediate}
                    \item Operasi memori memerlukan alamat yang valid
                    \item Ukuran operand harus 16-bit (word)
                \end{itemize}

            \subsubsection{PUSHF/POPF (flag register)}
                Instruksi \texttt{PUSHF} dan \texttt{POPF} memungkinkan penyimpanan dan pemulihan register flags. Ini sangat berguna saat memodifikasi flags sementara atau dalam konteks interupsi.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Operasi PUSHF/POPF, label={lst:pushf-popf}]
; Simpan dan pulihkan flags
pushf                   ; Simpan semua flags ke stack
; ... operasi yang mengubah flags ...
popf                    ; Pulihkan flags dari stack

; Contoh penggunaan dalam prosedur
procedure_start:
    pushf               ; Simpan flags awal
    push ax             ; Simpan register yang digunakan
    push bx
    
    ; ... kode prosedur ...
    
    pop  bx             ; Pulihkan register
    pop  ax
    popf                ; Pulihkan flags
    ret

; Contoh penggunaan untuk mengubah interrupt flag
pushf                   ; Simpan flags
cli                     ; Clear interrupt flag (disable interrupts)
; ... kode kritis ...
popf                    ; Pulihkan flags (enable interrupts)
                \end{lstlisting}

                \textbf{Flags yang Disimpan:}
                \begin{itemize}
                    \item Carry Flag (CF)
                    \item Parity Flag (PF)
                    \item Auxiliary Carry Flag (AF)
                    \item Zero Flag (ZF)
                    \item Sign Flag (SF)
                    \item Trap Flag (TF)
                    \item Interrupt Flag (IF)
                    \item Direction Flag (DF)
                    \item Overflow Flag (OF)
                \end{itemize}

        \subsection{Instruksi Subrutin}
            \subsubsection{CALL dan RET}
                Instruksi \texttt{CALL} dan \texttt{RET} adalah dasar dari pemrograman modular dalam assembly. \texttt{CALL} menyimpan alamat kembali ke stack dan melompat ke subrutin, sedangkan \texttt{RET} memulihkan alamat kembali dan kembali ke pemanggil.

                \textbf{Jenis CALL:}
                \begin{itemize}
                    \item \textbf{Near CALL}: Menyimpan hanya \texttt{IP} (2 byte), melompat dalam segmen yang sama
                    \item \textbf{Far CALL}: Menyimpan \texttt{CS:IP} (4 byte), melompat antar segmen
                \end{itemize}

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Contoh CALL dan RET, label={lst:call-ret-example}]
; Contoh Near CALL
main:
    mov ax, 100
    mov bx, 200
    call add_numbers    ; Near call ke subrutin
    ; AX sekarang berisi hasil penjumlahan
    int 20h

add_numbers:
    add ax, bx          ; AX = AX + BX
    ret                 ; Kembali ke pemanggil

; Contoh Far CALL
main:
    call far ptr far_procedure    ; Far call ke segmen lain
    int 20h

far_procedure:
    ; ... kode prosedur ...
    retf                ; Far return (mengembalikan CS:IP)
                \end{lstlisting}

                \textbf{Mekanisme CALL:}
                \begin{enumerate}
                    \item Push return address ke stack
                    \item Jump ke target address
                    \item Eksekusi subrutin
                    \item RET memulihkan return address dari stack
                    \item Jump kembali ke pemanggil
                \end{enumerate}

            \subsubsection{RET dengan parameter}
                Instruksi \texttt{RET n} memungkinkan pembersihan parameter stack secara otomatis. Setelah memulihkan return address, \texttt{SP} dinaikkan sebesar \(n\) byte untuk membersihkan parameter yang dikirim oleh pemanggil.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Contoh RET dengan Parameter, label={lst:ret-with-param}]
; Contoh penggunaan RET n untuk membersihkan parameter
main:
    push 100            ; Parameter pertama
    push 200            ; Parameter kedua
    call calculate_sum  ; Call subrutin
    ; Stack sudah bersih setelah RET 4
    int 20h

calculate_sum:
    push bp             ; Simpan BP
    mov bp, sp          ; BP = SP
    mov ax, [bp+6]      ; AX = parameter kedua (200)
    add ax, [bp+4]      ; AX = AX + parameter pertama (100)
    pop bp              ; Pulihkan BP
    ret 4               ; Return dan bersihkan 4 byte parameter
                \end{lstlisting}

                \textbf{Keuntungan RET n:}
                \begin{itemize}
                    \item Mengurangi kode pemanggil (tidak perlu \texttt{ADD SP, n})
                    \item Konsisten dengan konvensi Pascal
                    \item Mengurangi kemungkinan lupa membersihkan stack
                \end{itemize}

            \subsubsection{Penanganan return address}
                Return address adalah alamat instruksi berikutnya setelah \texttt{CALL} yang disimpan di stack. Penting untuk tidak menimpa area ini dengan operasi stack yang tidak terkendali.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Penanganan Return Address, label={lst:return-address}]
; Contoh yang BENAR - menyimpan register sebelum menggunakan stack
procedure:
    push ax             ; Simpan register yang akan digunakan
    push bx
    ; ... kode prosedur ...
    pop  bx             ; Pulihkan register (urutan terbalik)
    pop  ax
    ret                 ; Return address masih utuh

; Contoh yang SALAH - menimpa return address
procedure_wrong:
    push ax
    push bx
    push cx             ; Terlalu banyak push
    ; ... kode prosedur ...
    pop  cx
    pop  bx
    pop  ax
    ret                 ; Return address mungkin rusak
                \end{lstlisting}

                \textbf{Stack Layout saat CALL:}
                \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \textbf{Alamat Relatif} & \textbf{Konten} & \textbf{Keterangan} \\
                        \hline
                        SP + 2 & Return Address & Alamat kembali (IP atau CS:IP) \\
                        \hline
                        SP + 4 & Parameter 1 & Parameter pertama \\
                        \hline
                        SP + 6 & Parameter 2 & Parameter kedua \\
                        \hline
                        ... & ... & ... \\
                        \hline
                    \end{tabular}
                \end{center}

        \subsection{Parameter dalam Subrutin}
            \subsubsection{Melalui register}
                Metode paling cepat untuk mengirim parameter adalah melalui register. Namun, jumlah register terbatas dan harus didokumentasikan dengan baik.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Parameter melalui Register, label={lst:param-register}]
; Contoh parameter melalui register
main:
    mov ax, 100         ; Parameter pertama di AX
    mov bx, 200         ; Parameter kedua di BX
    call multiply       ; Call subrutin
    ; Hasil di AX (100 * 200 = 20000)
    int 20h

multiply:
    mul bx              ; AX = AX * BX
    ret                 ; Return value di AX

; Contoh dengan multiple parameters
main:
    mov ax, 10          ; Parameter 1: nilai
    mov bx, 5           ; Parameter 2: pangkat
    mov cx, 2           ; Parameter 3: multiplier
    call power_calc     ; Call subrutin
    int 20h

power_calc:
    ; AX = nilai, BX = pangkat, CX = multiplier
    push dx             ; Simpan DX karena akan digunakan
    mov dx, ax          ; DX = nilai awal
power_loop:
    cmp bx, 1           ; Jika pangkat = 1, selesai
    je power_done
    mul dx              ; AX = AX * nilai
    dec bx              ; Kurangi pangkat
    jmp power_loop
power_done:
    mul cx              ; Kalikan dengan multiplier
    pop dx              ; Pulihkan DX
    ret
                \end{lstlisting}

                \textbf{Keuntungan:}
                \begin{itemize}
                    \item Akses sangat cepat
                    \item Tidak memerlukan akses memori
                    \item Sederhana untuk implementasi
                \end{itemize}

                \textbf{Keterbatasan:}
                \begin{itemize}
                    \item Jumlah parameter terbatas (hanya beberapa register)
                    \item Register harus didokumentasikan dengan jelas
                    \item Tidak cocok untuk parameter besar atau banyak
                \end{itemize}

            \subsubsection{Melalui stack}
                Metode paling fleksibel untuk mengirim parameter adalah melalui stack. Ini memungkinkan pengiriman banyak parameter dan parameter dengan ukuran besar.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Parameter melalui Stack, label={lst:param-stack}]
; Contoh parameter melalui stack
main:
    push 100            ; Parameter ketiga
    push 200            ; Parameter kedua  
    push 300            ; Parameter pertama
    call add_three      ; Call subrutin
    add sp, 6           ; Bersihkan parameter dari stack
    ; Hasil di AX (100 + 200 + 300 = 600)
    int 20h

add_three:
    push bp             ; Simpan BP
    mov bp, sp          ; BP = SP (buat stack frame)
    
    ; Akses parameter (urutan terbalik karena stack)
    mov ax, [bp+8]      ; AX = parameter pertama (300)
    add ax, [bp+6]      ; AX = AX + parameter kedua (200)
    add ax, [bp+4]      ; AX = AX + parameter ketiga (100)
    
    pop bp              ; Pulihkan BP
    ret                 ; Return value di AX

; Contoh dengan string parameter
main:
    push offset string1 ; Push alamat string pertama
    push offset string2 ; Push alamat string kedua
    call compare_strings
    add sp, 4           ; Bersihkan 2 parameter (2 word)
    int 20h

compare_strings:
    push bp
    mov bp, sp
    push si             ; Simpan register yang digunakan
    push di
    
    mov si, [bp+6]      ; SI = alamat string pertama
    mov di, [bp+4]      ; DI = alamat string kedua
    
compare_loop:
    mov al, [si]        ; Load karakter dari string pertama
    cmp al, [di]        ; Bandingkan dengan string kedua
    jne compare_done    ; Jika berbeda, selesai
    cmp al, 0           ; Jika null terminator, selesai
    je compare_done
    inc si              ; Increment pointer
    inc di
    jmp compare_loop
    
compare_done:
    pop di              ; Pulihkan register
    pop si
    pop bp
    ret
                \end{lstlisting}

                \textbf{Stack Frame Layout:}
                \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \textbf{Offset dari BP} & \textbf{Konten} & \textbf{Keterangan} \\
                        \hline
                        BP + 8 & Parameter 1 & Parameter pertama \\
                        \hline
                        BP + 6 & Parameter 2 & Parameter kedua \\
                        \hline
                        BP + 4 & Parameter 3 & Parameter ketiga \\
                        \hline
                        BP + 2 & Return Address & Alamat kembali \\
                        \hline
                        BP + 0 & Saved BP & BP yang disimpan \\
                        \hline
                        BP - 2 & Local Var 1 & Variabel lokal pertama \\
                        \hline
                        BP - 4 & Local Var 2 & Variabel lokal kedua \\
                        \hline
                    \end{tabular}
                \end{center}

            \subsubsection{Melalui memori}
                Parameter dapat disimpan dalam blok memori yang disepakati antara pemanggil dan subrutin. Ini berguna untuk parameter besar atau data yang kompleks.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Parameter melalui Memori, label={lst:param-memory}]
; Contoh parameter melalui memori
.DATA
    param_block dw 100, 200, 300, 0    ; Blok parameter
    result_area dw 0                   ; Area untuk hasil

.CODE
main:
    call process_data   ; Call subrutin
    ; Hasil tersimpan di result_area
    int 20h

process_data:
    push ax             ; Simpan register
    push bx
    push si
    
    mov si, offset param_block  ; SI menunjuk ke blok parameter
    mov ax, 0                   ; AX = accumulator
    
sum_loop:
    mov bx, [si]        ; BX = parameter berikutnya
    cmp bx, 0           ; Jika 0, selesai
    je sum_done
    add ax, bx          ; Tambahkan ke accumulator
    add si, 2           ; Increment pointer (word = 2 bytes)
    jmp sum_loop
    
sum_done:
    mov [result_area], ax    ; Simpan hasil
    pop si              ; Pulihkan register
    pop bx
    pop ax
    ret

; Contoh dengan struktur data
.DATA
    student_record:
        dw 12345        ; Student ID
        dw 85           ; Grade 1
        dw 90           ; Grade 2
        dw 78           ; Grade 3
        dw 0            ; Terminator
    
    average_result dw 0 ; Hasil rata-rata

.CODE
main:
    call calculate_average
    int 20h

calculate_average:
    push ax
    push bx
    push cx
    push si
    
    mov si, offset student_record
    mov ax, 0           ; AX = sum
    mov cx, 0           ; CX = count
    
avg_loop:
    mov bx, [si]        ; BX = grade
    cmp bx, 0           ; Jika terminator, selesai
    je avg_done
    add ax, bx          ; Tambahkan ke sum
    inc cx              ; Increment count
    add si, 2           ; Next grade
    jmp avg_loop
    
avg_done:
    div cx              ; AX = sum / count
    mov [average_result], ax
    pop si
    pop cx
    pop bx
    pop ax
    ret
                \end{lstlisting}

            \subsubsection{Return value}
                Konvensi umum untuk return value adalah menggunakan register \texttt{AX} untuk nilai tunggal, atau \texttt{DX:AX} untuk nilai 32-bit.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Return Value, label={lst:return-value}]
; Contoh return value tunggal
main:
    mov ax, 100
    mov bx, 200
    call multiply_simple
    ; Hasil di AX
    int 20h

multiply_simple:
    mul bx              ; AX = AX * BX
    ret                 ; Return value di AX

; Contoh return value 32-bit
main:
    mov ax, 1000
    mov bx, 2000
    call multiply_32bit
    ; Hasil 32-bit di DX:AX
    int 20h

multiply_32bit:
    mul bx              ; DX:AX = AX * BX
    ret                 ; Return value di DX:AX

; Contoh return value melalui memori
.DATA
    calculation_result dw 0

.CODE
main:
    mov ax, 50
    mov bx, 30
    call calculate_and_store
    ; Hasil tersimpan di calculation_result
    int 20h

calculate_and_store:
    add ax, bx          ; AX = AX + BX
    mov [calculation_result], ax
    ret
                \end{lstlisting}

            \subsubsection{Konvensi pemanggilan}
                Penting untuk menetapkan konvensi pemanggilan yang konsisten dalam proyek. Ini mencakup siapa yang bertanggung jawab menyimpan register dan membersihkan parameter.

                \begin{table}[H]
                    \centering
                    \caption{Konvensi Pemanggilan Umum}
                    \begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
                        \hline
                        \textbf{Konvensi} & \textbf{Caller-saves} & \textbf{Callee-saves} \\
                        \hline
                        \textbf{Register} & AX, BX, CX, DX & SI, DI, BP \\
                        \hline
                        \textbf{Parameter} & Stack (push sebelum call) & Stack (akses via BP) \\
                        \hline
                        \textbf{Cleanup} & ADD SP, n setelah call & RET n dalam subrutin \\
                        \hline
                        \textbf{Return} & AX (16-bit), DX:AX (32-bit) & AX (16-bit), DX:AX (32-bit) \\
                        \hline
                    \end{tabular}
                    \label{tab:calling-conventions}
                \end{table}

            \subsubsection{Stack Frame Berbasis BP}
                Stack frame berbasis BP adalah teknik standar untuk mengelola parameter dan variabel lokal dalam subrutin. Ini memungkinkan akses yang konsisten dan mudah dipahami.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Stack Frame Berbasis BP, label={lst:stack-frame-bp}]
; Contoh lengkap stack frame berbasis BP
main:
    push 100            ; Parameter ketiga
    push 200            ; Parameter kedua
    push 300            ; Parameter pertama
    call complex_calc   ; Call subrutin
    add sp, 6           ; Bersihkan parameter
    int 20h

complex_calc:
    ; Prolog: Setup stack frame
    push bp             ; Simpan BP lama
    mov bp, sp          ; BP = SP (base of frame)
    sub sp, 4           ; Alokasi 4 byte untuk variabel lokal
    
    ; Akses parameter (offset positif dari BP)
    mov ax, [bp+8]      ; AX = parameter pertama (300)
    mov bx, [bp+6]      ; BX = parameter kedua (200)
    mov cx, [bp+4]      ; CX = parameter ketiga (100)
    
    ; Akses variabel lokal (offset negatif dari BP)
    mov [bp-2], ax      ; Simpan hasil sementara
    mov [bp-4], bx      ; Simpan hasil sementara
    
    ; Perhitungan kompleks
    add ax, bx          ; AX = AX + BX
    add ax, cx          ; AX = AX + CX
    mul word ptr [bp-2] ; AX = AX * nilai tersimpan
    
    ; Epilog: Cleanup stack frame
    mov sp, bp          ; Restore SP
    pop bp              ; Restore BP lama
    ret                 ; Return value di AX
                \end{lstlisting}

                \textbf{Keuntungan Stack Frame:}
                \begin{itemize}
                    \item Akses parameter dan variabel lokal yang konsisten
                    \item Mudah untuk debugging dan maintenance
                    \item Mendukung nested calls dan rekursi
                    \item Standard dalam pemrograman assembly profesional
                \end{itemize}

            \subsubsection{Ragam Konvensi Pemanggilan (cdecl vs pascal)}
                Dalam ekosistem DOS 16-bit, terdapat dua konvensi utama untuk pemanggilan subrutin: \textbf{cdecl} dan \textbf{pascal}.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Konvensi Cdecl vs Pascal, label={lst:cdecl-pascal}]
; Konvensi CDECL (C-style)
; Caller membersihkan parameter
main:
    push 100            ; Parameter ketiga
    push 200            ; Parameter kedua
    push 300            ; Parameter pertama
    call cdecl_function
    add sp, 6           ; Caller membersihkan parameter
    int 20h

cdecl_function:
    push bp
    mov bp, sp
    ; Akses parameter via [bp+4], [bp+6], [bp+8]
    mov ax, [bp+8]      ; Parameter pertama
    add ax, [bp+6]      ; Tambah parameter kedua
    add ax, [bp+4]      ; Tambah parameter ketiga
    pop bp
    ret                 ; Tidak ada cleanup

; Konvensi PASCAL
; Callee membersihkan parameter
main:
    push 100            ; Parameter ketiga
    push 200            ; Parameter kedua
    push 300            ; Parameter pertama
    call pascal_function
    ; Tidak perlu cleanup - callee yang membersihkan
    int 20h

pascal_function:
    push bp
    mov bp, sp
    ; Akses parameter via [bp+4], [bp+6], [bp+8]
    mov ax, [bp+8]      ; Parameter pertama
    add ax, [bp+6]      ; Tambah parameter kedua
    add ax, [bp+4]      ; Tambah parameter ketiga
    pop bp
    ret 6               ; Callee membersihkan 6 byte parameter
                \end{lstlisting}

                \begin{table}[H]
                    \centering
                    \caption{Perbandingan Konvensi CDECL vs PASCAL}
                    \begin{tabular}{|p{2.5cm}|p{6cm}|p{6cm}|}
                        \hline
                        \textbf{Aspek} & \textbf{CDECL} & \textbf{PASCAL} \\
                        \hline
                        \textbf{Parameter Cleanup} & Caller membersihkan & Callee membersihkan \\
                        \hline
                        \textbf{Urutan Parameter} & Right-to-left & Left-to-right \\
                        \hline
                        \textbf{Code Size} & Lebih besar (ADD SP,n) & Lebih kecil \\
                        \hline
                        \textbf{Flexibility} & Mendukung variadic functions & Tidak mendukung \\
                        \hline
                        \textbf{Compatibility} & C/C++ compatible & Pascal compatible \\
                        \hline
                    \end{tabular}
                    \label{tab:cdecl-pascal-comparison}
                \end{table}

            \subsubsection{Near vs Far Call/Return}
                Intel 8086 mendukung dua jenis pemanggilan: near (dalam segmen) dan far (antar segmen). Perbedaan utama adalah ukuran return address yang disimpan.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Near vs Far Call, label={lst:near-far-call}]
; Near Call (dalam segmen yang sama)
main:
    call near_procedure  ; Hanya menyimpan IP (2 byte)
    int 20h

near_procedure:
    ; ... kode prosedur ...
    ret                 ; Mengembalikan IP

; Far Call (antar segmen)
main:
    call far ptr far_procedure  ; Menyimpan CS:IP (4 byte)
    int 20h

far_procedure:
    ; ... kode prosedur ...
    retf                ; Mengembalikan CS:IP

; Contoh penggunaan dalam program besar
.DATA
    message db 'Hello from far procedure!$'

.CODE
main:
    ; Setup data segment
    mov ax, @data
    mov ds, ax
    
    ; Far call ke prosedur di segmen lain
    call far ptr display_message
    int 20h

display_message:
    ; Prosedur di segmen lain
    mov dx, offset message
    mov ah, 09h
    int 21h
    retf
                \end{lstlisting}

                \textbf{Pertimbangan Near vs Far:}
                \begin{itemize}
                    \item \textbf{Near Call}: Lebih cepat, hanya 2 byte stack, tapi terbatas dalam segmen
                    \item \textbf{Far Call}: Lebih lambat, 4 byte stack, tapi bisa melompat antar segmen
                    \item \textbf{Stack Usage}: Far call menggunakan lebih banyak stack space
                    \item \textbf{Performance}: Near call lebih efisien untuk prosedur dalam segmen yang sama
                \end{itemize}

            \subsubsection{Rekursi dan Reentransi}
                Rekursi memerlukan manajemen stack yang hati-hati. Setiap level rekursi memerlukan stack frame yang terpisah.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Contoh Rekursi, label={lst:recursion-example}]
; Contoh rekursi: Faktorial
main:
    mov ax, 5           ; Hitung 5!
    call factorial
    ; Hasil di AX (5! = 120)
    int 20h

factorial:
    ; Base case: jika n <= 1, return 1
    cmp ax, 1
    jle factorial_base
    
    ; Recursive case: n! = n * (n-1)!
    push ax             ; Simpan n
    dec ax              ; n-1
    call factorial      ; Rekursi: hitung (n-1)!
    pop bx              ; BX = n
    mul bx              ; AX = AX * n (hasil rekursi * n)
    ret

factorial_base:
    mov ax, 1           ; Return 1 untuk base case
    ret

; Contoh rekursi: Fibonacci
main:
    mov ax, 10          ; Hitung Fibonacci(10)
    call fibonacci
    int 20h

fibonacci:
    cmp ax, 2
    jle fib_base        ; Jika n <= 2, return 1
    
    push ax             ; Simpan n
    dec ax              ; n-1
    call fibonacci      ; Fibonacci(n-1)
    push ax             ; Simpan hasil Fibonacci(n-1)
    
    pop ax              ; AX = Fibonacci(n-1)
    pop bx              ; BX = n
    sub bx, 2           ; n-2
    push ax             ; Simpan Fibonacci(n-1)
    mov ax, bx          ; AX = n-2
    call fibonacci      ; Fibonacci(n-2)
    
    pop bx              ; BX = Fibonacci(n-1)
    add ax, bx          ; AX = Fibonacci(n-2) + Fibonacci(n-1)
    ret

fib_base:
    mov ax, 1           ; Return 1 untuk base case
    ret
                \end{lstlisting}

                \textbf{Pertimbangan Rekursi:}
                \begin{itemize}
                    \item \textbf{Stack Overflow}: Pastikan ada cukup stack space
                    \item \textbf{Base Case}: Selalu ada kondisi terminasi
                    \item \textbf{Performance}: Rekursi bisa lambat untuk nilai besar
                    \item \textbf{Memory}: Setiap level menggunakan stack frame
                \end{itemize}

            \subsubsection{Interupsi dan Stack}
                Interupsi menggunakan stack untuk menyimpan konteks CPU. Penting untuk memahami bagaimana interupsi mempengaruhi stack.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Interupsi dan Stack, label={lst:interrupt-stack}]
; Contoh interrupt handler
interrupt_handler:
    ; CPU otomatis push: FLAGS, CS, IP
    push ax             ; Simpan register yang digunakan
    push bx
    push cx
    push dx
    
    ; Kode interrupt handler
    mov ax, 0B800h      ; Video memory segment
    mov es, ax
    mov di, 0           ; Offset ke posisi cursor
    mov al, '!'         ; Karakter untuk ditampilkan
    mov ah, 07h         ; Attribute (putih pada hitam)
    mov [es:di], ax     ; Tampilkan karakter
    
    ; Restore register
    pop dx
    pop cx
    pop bx
    pop ax
    iret                ; Return dari interrupt (restore FLAGS, CS, IP)

; Contoh penggunaan PUSHF/POPF dalam critical section
critical_section:
    pushf               ; Simpan flags
    cli                 ; Disable interrupts
    ; ... kode kritis yang tidak boleh diinterrupt ...
    popf                ; Restore flags (enable interrupts)
    ret

; Contoh interrupt-safe procedure
safe_procedure:
    pushf               ; Simpan flags
    push ax             ; Simpan register
    push bx
    
    ; Kode prosedur
    mov ax, 100
    mov bx, 200
    add ax, bx
    
    pop bx              ; Restore register
    pop ax
    popf                ; Restore flags
    ret
                \end{lstlisting}

                \textbf{Stack Layout saat Interrupt:}
                \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \textbf{Offset dari SP} & \textbf{Konten} & \textbf{Keterangan} \\
                        \hline
                        SP + 0 & FLAGS & Status flags \\
                        \hline
                        SP + 2 & CS & Code segment \\
                        \hline
                        SP + 4 & IP & Instruction pointer \\
                        \hline
                    \end{tabular}
                \end{center}

            \subsubsection{Deteksi Overflow Stack}
                Stack overflow adalah masalah serius yang dapat merusak program. Berikut beberapa teknik deteksi dan pencegahan.

                \begin{lstlisting}[language={[x86masm]Assembler}, caption=Deteksi Stack Overflow, label={lst:stack-overflow}]
; Contoh deteksi stack overflow dengan guard
.DATA
    stack_guard dw 0DEADh    ; Nilai guard
    initial_sp dw 0          ; SP awal

.CODE
main:
    ; Setup stack dengan guard
    mov ax, stack_segment
    mov ss, ax
    mov sp, stack_size
    mov [initial_sp], sp     ; Simpan SP awal
    
    ; Setup guard di bawah stack
    mov ax, stack_segment
    mov es, ax
    mov di, stack_size - 2   ; Posisi guard
    mov ax, [stack_guard]
    mov [es:di], ax          ; Set guard
    
    ; Jalankan program
    call main_program
    int 20h

check_stack_overflow:
    ; Cek apakah guard masih utuh
    mov ax, stack_segment
    mov es, ax
    mov di, stack_size - 2
    mov ax, [es:di]
    cmp ax, [stack_guard]
    jne stack_overflow_error
    ret

stack_overflow_error:
    ; Handle stack overflow
    mov dx, offset overflow_msg
    mov ah, 09h
    int 21h
    int 20h

overflow_msg db 'Stack Overflow Detected!$'

; Contoh dengan margin stack
setup_safe_stack:
    mov ax, stack_segment
    mov ss, ax
    mov sp, stack_size - 100  ; Tinggalkan margin 100 byte
    ret

; Contoh dengan batas maksimal stack usage
max_stack_usage dw 500        ; Maksimal 500 byte stack usage

check_stack_usage:
    mov ax, [initial_sp]
    sub ax, sp                ; Hitung penggunaan stack
    cmp ax, [max_stack_usage]
    ja stack_usage_error
    ret

stack_usage_error:
    mov dx, offset usage_msg
    mov ah, 09h
    int 21h
    int 20h

usage_msg db 'Stack Usage Exceeded Limit!$'
                \end{lstlisting}

                \textbf{Teknik Pencegahan Stack Overflow:}
                \begin{itemize}
                    \item \textbf{Stack Guard}: Nilai khusus di bawah stack
                    \item \textbf{Margin Stack}: Tinggalkan ruang kosong
                    \item \textbf{Usage Monitoring}: Pantau penggunaan stack
                    \item \textbf{Size Limits}: Batasi ukuran stack frame
                    \item \textbf{Recursion Limits}: Batasi kedalaman rekursi
                \end{itemize}

    \section{Contoh Program Lengkap}
        \subsection{Kalkulator Sederhana dengan Subrutin}
            Berikut adalah contoh program lengkap yang menggunakan berbagai konsep stack dan subrutin.

            \begin{lstlisting}[language={[x86masm]Assembler}, caption=Program Kalkulator Lengkap, label={lst:calculator-complete}]
.MODEL SMALL
.STACK 100h
.DATA
    msg_welcome db 'Calculator Program$'
    msg_input1 db 'Enter first number: $'
    msg_input2 db 'Enter second number: $'
    msg_result db 'Result: $'
    msg_operation db 'Operation (1=Add, 2=Sub, 3=Mul, 4=Div): $'
    newline db 13, 10, '$'
    buffer db 10 dup(?)

.CODE
main PROC
    mov ax, @data
    mov ds, ax
    
    ; Tampilkan pesan selamat datang
    mov dx, offset msg_welcome
    call print_string
    call print_newline
    
    ; Input operasi
    mov dx, offset msg_operation
    call print_string
    call read_number
    push ax              ; Simpan operasi ke stack
    
    ; Input angka pertama
    mov dx, offset msg_input1
    call print_string
    call read_number
    push ax              ; Simpan angka pertama ke stack
    
    ; Input angka kedua
    mov dx, offset msg_input2
    call print_string
    call read_number
    push ax              ; Simpan angka kedua ke stack
    
    ; Panggil kalkulator
    call calculator
    
    ; Tampilkan hasil
    mov dx, offset msg_result
    call print_string
    call print_number
    call print_newline
    
    mov ax, 4C00h
    int 21h
main ENDP

; Subrutin: Kalkulator
; Parameter: [SP+4] = angka pertama, [SP+6] = angka kedua, [SP+8] = operasi
calculator PROC
    push bp
    mov bp, sp
    
    mov ax, [bp+6]      ; AX = angka pertama
    mov bx, [bp+4]      ; BX = angka kedua
    mov cx, [bp+8]      ; CX = operasi
    
    cmp cx, 1
    je do_add
    cmp cx, 2
    je do_sub
    cmp cx, 3
    je do_mul
    cmp cx, 4
    je do_div
    jmp calc_done
    
do_add:
    add ax, bx
    jmp calc_done
    
do_sub:
    sub ax, bx
    jmp calc_done
    
do_mul:
    mul bx
    jmp calc_done
    
do_div:
    cmp bx, 0
    je div_error
    div bx
    jmp calc_done
    
div_error:
    mov ax, 0           ; Return 0 untuk error
    jmp calc_done
    
calc_done:
    pop bp
    ret 6               ; Bersihkan 6 byte parameter
calculator ENDP

; Subrutin: Print string
print_string PROC
    push ax
    mov ah, 09h
    int 21h
    pop ax
    ret
print_string ENDP

; Subrutin: Print newline
print_newline PROC
    push dx
    push ax
    mov dx, offset newline
    mov ah, 09h
    int 21h
    pop ax
    pop dx
    ret
print_newline ENDP

; Subrutin: Read number (sederhana)
read_number PROC
    push bx
    push cx
    push dx
    
    mov ah, 01h         ; Read character
    int 21h
    sub al, '0'         ; Convert to number
    mov ah, 0
    mov bx, ax          ; BX = angka
    
    mov ah, 01h         ; Read next character
    int 21h
    cmp al, 13          ; Jika Enter, selesai
    je read_done
    
    sub al, '0'         ; Convert to number
    mov ah, 0
    mov cx, 10
    mul cx              ; AX = AX * 10
    add ax, bx          ; AX = AX + BX
    
read_done:
    pop dx
    pop cx
    pop bx
    ret
read_number ENDP

; Subrutin: Print number
print_number PROC
    push ax
    push bx
    push cx
    push dx
    
    mov bx, 10
    mov cx, 0
    
print_loop:
    mov dx, 0
    div bx              ; AX = AX / 10, DX = remainder
    push dx             ; Push digit
    inc cx              ; Increment counter
    cmp ax, 0
    jne print_loop
    
print_digits:
    pop dx              ; Pop digit
    add dl, '0'         ; Convert to character
    mov ah, 02h         ; Print character
    int 21h
    loop print_digits
    
    pop dx
    pop cx
    pop bx
    pop ax
    ret
print_number ENDP

END main
            \end{lstlisting}

        \subsection{Analisis Program}
            Program di atas menunjukkan penggunaan lengkap konsep stack dan subrutin:

            \begin{itemize}
                \item \textbf{Parameter Passing}: Menggunakan stack untuk mengirim parameter
                \item \textbf{Stack Frame}: Menggunakan BP untuk akses parameter yang konsisten
                \item \textbf{Register Management}: Menyimpan dan memulihkan register yang digunakan
                \item \textbf{Modular Design}: Program dibagi menjadi subrutin yang terpisah
                \item \textbf{Error Handling}: Menangani kasus pembagian dengan nol
                \item \textbf{Stack Cleanup}: Menggunakan RET n untuk membersihkan parameter
            \end{itemize}

    \section{Kesimpulan}
        Stack dan subrutin adalah komponen fundamental dalam pemrograman assembly Intel 8086. Penguasaan konsep-konsep ini memungkinkan:

        \begin{itemize}
            \item \textbf{Pemrograman Modular}: Membagi program menjadi bagian-bagian yang dapat dikelola
            \item \textbf{Reusability}: Menggunakan subrutin yang sama untuk berbagai tujuan
            \item \textbf{Maintainability}: Memudahkan debugging dan maintenance
            \item \textbf{Efficiency}: Mengoptimalkan penggunaan register dan memori
            \item \textbf{Professional Development}: Mengikuti standar industri dalam pengembangan software
        \end{itemize}

        Penting untuk selalu mengikuti konvensi pemanggilan yang konsisten dan memastikan manajemen stack yang benar untuk menghindari stack overflow dan error lainnya.






\end{document}