\chapter{Pengenalan Bahasa Rakitan dan Sistem Bilangan}\label{ch:pengenalan}

\section{Tujuan Pembelajaran}\label{sec:pengenalan-tujuan}
Setelah mengikuti pertemuan ini, mahasiswa diharapkan mampu:
\begin{itemize}
    \item Menjelaskan definisi dan ruang lingkup bahasa rakitan (assembly language) serta kaitannya dengan arsitektur komputer.
    \item Menguraikan karakteristik bahasa tingkat rendah dan membandingkannya dengan bahasa tingkat tinggi.
    \item Mengidentifikasi keunggulan dan keterbatasan pemrograman assembly dalam konteks kinerja, portabilitas, dan pemeliharaan.
    \item Menjelaskan sistem bilangan biner dan heksadesimal, termasuk notasi, nilai tempat, dan relasi di antara keduanya.
    \item Melakukan konversi antar sistem bilangan (desimal, biner, heksadesimal) secara tepat dan efisien.
    \item Melakukan operasi aritmatika sederhana dalam sistem biner dan menjelaskan aturan pembawaan (carry) dan pinjaman (borrow).
    \item Mengaitkan konsep representasi data (bit, byte, word, two's complement, endianness) dengan perilaku program assembly.
\end{itemize}

\section{Pendahuluan}\label{sec:pengenalan-pendahuluan}

\subsection{Latar Belakang dan Konteks Historis}
Bahasa rakitan (assembly language) merupakan salah satu bahasa pemrograman tertua yang masih digunakan hingga saat ini \cite{wiki_assembly_language}. Konsep assembly language pertama kali dikembangkan pada tahun 1940-an sebagai respons terhadap kompleksitas pemrograman dalam bahasa mesin murni. Sebelum adanya assembly language, programmer harus menulis program menggunakan kode biner (0 dan 1) yang sangat sulit dibaca dan rentan terhadap kesalahan.

Perkembangan assembly language dimulai dengan munculnya komputer-komputer pertama seperti ENIAC dan UNIVAC \cite{wiki_8086}. Pada masa itu, programmer menggunakan machine code yang terdiri dari angka-angka biner yang mewakili instruksi dasar komputer. Proses ini sangat memakan waktu dan rawan kesalahan. Assembly language kemudian dikembangkan sebagai solusi dengan menyediakan mnemonik (singkatan yang mudah diingat) untuk menggantikan kode biner tersebut \cite{hyde2010art}.

\subsection{Mengapa Mempelajari Assembly Language?}
Meskipun assembly language dianggap sulit dan memakan waktu dalam pengembangan, ada beberapa alasan penting mengapa mempelajarinya tetap relevan:

\begin{enumerate}
\item \textbf{Pemahaman Fundamental Komputer}\\
Assembly language memberikan pemahaman mendalam tentang bagaimana komputer benar-benar bekerja. Mahasiswa akan memahami:
\begin{itemize}
    \item Cara CPU mengeksekusi instruksi
    \item Penggunaan register dan memori
    \item Mekanisme interupsi dan I/O
    \item Representasi data dalam komputer
\end{itemize}

\item \textbf{Optimasi Kinerja}\\
Dalam aplikasi yang memerlukan kinerja maksimal, seperti:
\begin{itemize}
    \item Sistem operasi dan kernel
    \item Driver perangkat keras
    \item Game engine dan aplikasi real-time
    \item Sistem embedded dan firmware
\end{itemize}

\item \textbf{Debugging dan Analisis}\\
Pemahaman assembly language sangat membantu dalam:
\begin{itemize}
    \item Debugging program yang sudah dikompilasi
    \item Reverse engineering
    \item Analisis malware dan keamanan
    \item Optimasi compiler
\end{itemize}

\item \textbf{Bidang Khusus}\\
Assembly language masih digunakan dalam bidang-bidang khusus seperti:
\begin{itemize}
    \item Pengembangan sistem operasi
    \item Pemrograman embedded systems
    \item Keamanan siber dan forensik digital
    \item Pengembangan compiler dan interpreter
\end{itemize}
\end{enumerate}

\section{Pengenalan Bahasa Rakitan dan\\Bahasa Tingkat Rendah}\label{sec:pengenalan-bahasa}

\subsection{Definisi dan Karakteristik Bahasa Rakitan}\label{subsec:pengenalan-definisi}

\subsubsection{Definisi bahasa rakitan (assembly language)}
Assembly language adalah bahasa pemrograman berlevel rendah yang menyediakan antarmuka langsung terhadap instruksi mesin (machine instructions) dari sebuah \textit{Instruction Set Architecture} (ISA) \cite{computer_organization_design}. Assembly language merupakan representasi mnemonik dari instruksi mesin. Setiap mnemonik (misal, \texttt{MOV}, \texttt{ADD}, \texttt{JMP}) biasanya berkorelasi dekat dengan \textit{opcode} biner yang dieksekusi CPU. Kode assembly dirakit (\textit{assembled}) oleh \textit{assembler} (misal: TASM, MASM, NASM) menjadi \textit{object code} atau berkas executable \cite{tutorials_point_assembly}.

Dalam konteks pembelajaran ini, kita akan fokus pada keluarga x86, khususnya Intel 8086 dan penerusnya, yang merupakan arsitektur yang paling banyak digunakan dalam komputer personal \cite{intel2019manual32}. Setiap instruksi assembly language memiliki korespondensi hampir satu-ke-satu dengan instruksi mesin. Misalnya, instruksi assembly \texttt{MOV AX, 5} akan diterjemahkan oleh assembler menjadi kode biner yang dapat dieksekusi langsung oleh CPU.

\subsubsection{Posisi Assembly dalam Hierarki Bahasa Pemrograman}
Dalam hierarki bahasa pemrograman, assembly language menempati posisi yang unik. Berikut adalah perbandingan dengan bahasa pemrograman lainnya:

\begin{center}
\begin{tabular}{p{0.28\textwidth} p{0.31\textwidth} p{0.31\textwidth}}
\hline
\textbf{Aspek} & \textbf{Assembly} & \textbf{Bahasa Tingkat Tinggi} \\
\hline
Abstraksi & Rendah; dekat hardware & Tinggi; jauh dari hardware \\
Portabilitas & Rendah (spesifik ISA) & Lebih tinggi (kompiler/VM) \\
Produktivitas & Rendah & Tinggi \\
Kinerja puncak & Sangat tinggi (jika dioptimasi) & Umumnya baik dengan optimasi otomatis \\
Pemeliharaan & Sulit & Lebih mudah \\
Manajemen Memori & Manual & Otomatis \\
Pustaka & Minim & Kaya \\
\hline
\end{tabular}
\end{center}

\textbf{Bahasa Tingkat Tinggi} (seperti Python, Java, C++):
\begin{itemize}
    \item Menyediakan abstraksi tinggi dengan tipe data kompleks
    \item Memiliki manajemen memori otomatis
    \item Kaya akan pustaka standar dan framework
    \item Mudah dibaca dan dipelihara
    \item Memerlukan compiler atau interpreter
\end{itemize}

\textbf{Bahasa Tingkat Menengah} (seperti C):
\begin{itemize}
    \item Menyediakan abstraksi sedang
    \item Memberikan kontrol manual terhadap memori
    \item Memiliki akses langsung ke hardware melalui pointer
    \item Di-compile ke assembly atau machine code
\end{itemize}

\textbf{Assembly Language}:
\begin{itemize}
    \item Memberikan kontrol granular atas register CPU, flags, dan layout memori
    \item Spesifik arsitektur (kode untuk x86 tidak portabel ke ARM)
    \item Memetakan langsung ke instruksi mesin
    \item Memerlukan pemahaman mendalam tentang arsitektur hardware
\end{itemize}

\subsubsection{Keunggulan dan Kelemahan Bahasa Rakitan}
\begin{itemize}
    \item \textbf{Keunggulan}:
    \begin{itemize}
        \item Kontrol penuh terhadap perangkat keras
        \item Optimasi mikroskopik untuk kinerja/ukuran
        \item Pemahaman mendalam atas \textit{runtime} dan \textit{calling convention}
        \item Kontrol granular atas register CPU, \textit{flags}, dan layout memori
        \item Kinerja dan jejak memori optimal untuk aplikasi \textit{embedded} atau komponen \textit{runtime-critical}
    \end{itemize}
    \item \textbf{Kelemahan}:
    \begin{itemize}
        \item Pengembangan lambat dan rentan kesalahan
        \item Sulit dipelihara dan kurang portabel (spesifik arsitektur)
        \item Minim dukungan pustaka
        \item Kurangnya abstraksi tingkat tinggi: Tidak tersedia struktur kontrol tingkat tinggi, \textit{garbage collector}, atau tipe kompleks secara bawaan
    \end{itemize}
\end{itemize}

\subsection{Aplikasi Bahasa Rakitan}\label{subsec:pengenalan-aplikasi}

\subsubsection{Aplikasi bahasa rakitan dalam pemrograman}
Assembly language masih digunakan dalam berbagai bidang khusus, terutama dalam aplikasi yang memerlukan kinerja maksimal, kontrol hardware langsung, atau ukuran kode yang minimal:

\begin{itemize}
    \item \textbf{Perangkat tertanam (embedded)}: \textit{firmware} mikrokontroler, \textit{device driver}, \textit{interrupt service routine}
    \item \textbf{Sistem rendah tingkat}: \textit{bootloader}, BIOS/UEFI, bagian \textit{kernel} yang sensitif kinerja
    \item \textbf{Optimasi hotspot}: Bagian kecil dari aplikasi yang memerlukan latensi minimal
    \item \textbf{Rekayasa balik dan keamanan}: Analisis \textit{malware}, \textit{exploit development}, \textit{debugging} pada level instruksi
    \item \textbf{Sistem operasi dan kernel}: Komponen inti yang memerlukan kontrol langsung terhadap hardware
    \item \textbf{Game engine dan aplikasi real-time}: Bagian kritis yang memerlukan kinerja optimal
    \item \textbf{Keamanan siber dan forensik digital}: Analisis dan reverse engineering
    \item \textbf{Pengembangan compiler dan interpreter}: Komponen runtime yang sensitif terhadap kinerja
\end{itemize}

\subsubsection{Contoh Kode Assembly 8086}
Berikut adalah contoh sederhana program assembly 8086 untuk demonstrasi \cite{susanto1995belajar}:

\begin{lstlisting}[language={[x86masm]Assembler}, caption={Cuplikan 8086 (ilustratif)}, label={lst:assembly_example}]
; Tambah dua nilai 8-bit, hasil di AL
org 100h          ; format .COM
mov al, 25h       ; AL = 0x25 (37 desimal)
add al, 13h       ; AL = AL + 0x13 (19 desimal) -> 0x38 (56)
; ... hasil dapat disimpan ke memori atau dipakai lanjut
int 20h           ; kembali ke DOS
\end{lstlisting}

Program ini menunjukkan:
\begin{itemize}
    \item Penggunaan direktif \texttt{org} untuk menentukan starting address
    \item Instruksi \texttt{mov} untuk memindahkan data
    \item Instruksi \texttt{add} untuk operasi aritmatika
    \item Interrupt \texttt{int 20h} untuk keluar dari program
\end{itemize}

\section{Sistem Bilangan dan Representasi Data}\label{sec:pengenalan-sistem-bilangan}

\subsection{Mengapa Sistem Bilangan Penting dalam Assembly?}
Dalam pemrograman assembly, pemahaman sistem bilangan sangat krusial karena:
\begin{itemize}
    \item Komputer bekerja dengan sistem biner (0 dan 1)
    \item Alamat memori dan register dinyatakan dalam heksadesimal
    \item Debugging dan analisis kode memerlukan konversi antar sistem bilangan
    \item Optimasi memerlukan pemahaman representasi data di level bit
\end{itemize}

\subsection{Sistem Bilangan Dasar}\label{subsec:pengenalan-dasar-bilangan}

\subsubsection{Sistem bilangan biner (basis 2)}
Biner menggunakan dua digit (0 dan 1). Nilai tempatnya adalah pangkat 2: \(\ldots, 2^3, 2^2, 2^1, 2^0\). Contoh: \(101010_2 = 1\cdot 2^5 + 0\cdot 2^4 + 1\cdot 2^3 + 0\cdot 2^2 + 1\cdot 2^1 + 0\cdot 2^0 = 42_{10}\).

\subsubsection{Sistem bilangan heksadesimal (basis 16)}
Heksadesimal menggunakan digit 0--9 dan A--F (A=10, B=11, \ldots, F=15). Setiap digit heksadesimal memetakan tepat ke 4 bit (\textit{nibble}). Contoh: \(\mathrm{D6}_{16} = 13\cdot 16^1 + 6\cdot 16^0 = 214_{10}\) dan dalam biner menjadi \(\mathrm{D} = 1101\), \(6 = 0110\) sehingga \(\mathrm{D6}_{16} = 1101\,0110_2\).

\subsubsection{Konversi antar sistem bilangan}
\paragraph{Desimal ke biner} gunakan pembagian berulang oleh 2 dan catat sisa; baca sisa dari belakang. Contoh: \(255_{10} \to 11111111_2\).
\paragraph{Biner ke desimal} gunakan penjumlahan nilai tempat. Contoh: \(11010110_2 = 128+64+16+4+2 = 214_{10}\).
\paragraph{Desimal ke heksadesimal} gunakan pembagian berulang oleh 16. Contoh: \(255_{10} \to \mathrm{FF}_{16}\).
\paragraph{Heksadesimal ke desimal} gunakan nilai tempat basis 16. Contoh: \(\mathrm{A5F}_{16} = 10\cdot 16^2 + 5\cdot 16 + 15 = 2655_{10}\).
\paragraph{Heksadesimal ke biner} peta setiap digit ke 4 bit: \(\mathrm{A5F}_{16} = 1010\,0101\,1111_2\).

\subsubsection{Operasi aritmatika dalam biner}
Penjumlahan biner mengikuti aturan: \(0+0=0\), \(0+1=1\), \(1+1=10_2\) (tulis 0, simpan \textit{carry} 1). Contoh:
\begin{verbatim}
   1011   (11 desimal)
 + 1101   (13 desimal)
 -------
  11000   (24 desimal)
\end{verbatim}

\subsection{Representasi Data dalam Komputer}\label{subsec:pengenalan-representasi-data}

\subsubsection{Satuan data dasar}
\begin{itemize}
    \item \textbf{Bit}: Unit terkecil data, bernilai 0 atau 1
    \item \textbf{Byte}: 8 bit; satuan standar untuk karakter dan data kecil
    \item \textbf{Word}: Pada 8086, word = 16 bit (2 byte)
    \item \textbf{Double Word}: 32 bit (4 byte)
\end{itemize}

\subsubsection{Representasi bilangan bertanda (Two's Complement)}
Two's complement adalah metode representasi bilangan bulat bertanda di mana \(-x\) diperoleh dengan komplemen satu kemudian tambah satu \cite{wiki_two_complement}. Contoh (8-bit): \(-13\) dari \(00001101_2\) menjadi \(11110011_2\).

\textbf{Keunggulan Two's Complement:}
\begin{itemize}
    \item Satu representasi untuk nol (tidak ada +0 dan -0)
    \item Operasi aritmatika sederhana
    \item Range simetris: untuk n-bit, range adalah \(-2^{n-1}\) sampai \(2^{n-1}-1\)
\end{itemize}

\subsubsection{Endianness (Little-Endian pada 8086)}
Endianness menentukan urutan penyimpanan byte dalam memori \cite{wiki_endianness}. 8086 menggunakan little-endian: \textit{least significant byte} disimpan pada alamat memori terendah. Contoh: word \(0x1234\) disimpan sebagai byte \(0x34\) lalu \(0x12\).

\textbf{Implikasi untuk Assembly:}
\begin{itemize}
    \item Penting saat mengakses data multi-byte
    \item Memengaruhi cara data dibaca dari/tulis ke memori
    \item Relevan untuk debugging dan analisis memori
\end{itemize}

\section{Contoh Soal dan Pembahasan}\label{sec:pengenalan-contoh}
\begin{enumerate}
    \item \textbf{Konversikan bilangan desimal 255 ke biner dan heksadesimal.}\\
    \(255_{10} = 11111111_2 = \mathrm{FF}_{16}\).

    \item \textbf{Konversikan bilangan biner \(11010110_2\) ke desimal dan heksadesimal.}\\
    Nilai tempat: \(128+64+16+4+2 = 214\). Kelompok 4-bit: \(1101\,0110_2 = \mathrm{D6}_{16}\).

    \item \textbf{Konversikan bilangan heksadesimal \(\mathrm{A5F}_{16}\) ke desimal dan biner.}\\
    \(10\cdot 256 + 5\cdot 16 + 15 = 2655_{10}\). Biner: \(\mathrm{A}\to 1010\), \(\mathrm{5}\to 0101\), \(\mathrm{F}\to 1111\) sehingga \(1010\,0101\,1111_2\).

    \item \textbf{Lakukan operasi penjumlahan biner: \(1011_2 + 1101_2\).}\\
    Hasil: \(11000_2\) sebagaimana langkah pembawaan pada contoh di atas (\(11+13=24\)).
\end{enumerate}

\section{Latihan}
Kerjakan tanpa kalkulator, tulis langkah konversi/aritmatika secara jelas.
\begin{enumerate}
    \item Ubah ke biner dan heksadesimal: \(37_{10}\), \(1023_{10}\), \(4095_{10}\).
    \item Ubah ke desimal dan heksadesimal: \(10010101_2\), \(11110000_2\), \(101011110101_2\).
    \item Ubah ke desimal dan biner: \(\mathrm{7B}_{16}\), \(\mathrm{1C3}_{16}\), \(\mathrm{FE}_{16}\).
    \item Hitung penjumlahan biner: \(11101_2 + 10111_2\), \(101010_2 + 1111_2\).
    \item Untuk 8-bit two's complement, representasikan \(-5\), \(-27\), dan verifikasi dengan penjumlahan dengan nilai positifnya menghasilkan nol (modulo 256).
\end{enumerate}

\section{Tugas}
\begin{itemize}
    \item \textbf{Tabel konversi 0--15}: Buat tabel berisi tiga kolom: desimal, biner (4-bit), heksadesimal. Gunakan lingkungan \texttt{tabular} LaTeX, pastikan format rapi dan konsisten.
    \item \textbf{Esai singkat (300--500 kata)}: Jelaskan mengapa heksadesimal sering digunakan dalam pemrograman \textit{low-level} (alamat memori, \textit{debugging}, \textit{bitmask}, korespondensi nibble--hex, keterbacaan). Sertakan contoh konkret (mis., merepresentasikan pola \textit{bit} register prosesor).
    \item \textbf{Aplikasi assembly dalam kehidupan sehari-hari}: Berikan minimal dua contoh nyata (mis., \textit{bootloader}, \textit{driver} perangkat, \textit{firmware} mikrokontroler). Jelaskan alur singkat peran assembly dan alasannya digunakan (kinerja, determinisme, ukuran kode).
\end{itemize}
\noindent\textbf{Keluaran yang dikumpulkan}: 
(i) berkas PDF berisi jawaban dan tabel; 
(ii) berkas \LaTeX{} sumber; 
(iii) jika menggunakan kode, lampirkan cuplikan dan komentar.
