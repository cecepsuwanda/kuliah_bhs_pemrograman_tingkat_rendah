\chapter{Instruksi Dasar: Perpindahan Data dan Aritmatika}

\section{Tujuan Pembelajaran}
Setelah pertemuan ini, mahasiswa mampu:
\begin{itemize}
    \item Menggunakan instruksi perpindahan data \texttt{MOV} dengan benar pada variasi operand register dan memori.
    \item Melakukan operasi aritmatika dasar (\texttt{ADD}, \texttt{SUB}, \texttt{MUL}, \texttt{DIV}) pada data 8/16-bit.
    \item Menjelaskan pengaruh instruksi aritmatika terhadap \textit{flag} prosesor (\texttt{CF}, \texttt{ZF}, \texttt{SF}, \texttt{OF}, \texttt{PF}, \texttt{AF}).
    \item Menulis program aritmatika sederhana yang aman dan memperhatikan kasus tepi (overflow, pembagian nol).
\end{itemize}

\section{Pendahuluan}
Instruksi perpindahan dan aritmatika merupakan fondasi pemrograman assembly \cite{susanto1995belajar}. Pemahaman mendalam mengenai operand, mode pengalamatan, dan efek \textit{flag} akan menentukan ketepatan logika program. Pada 8086, variasi operand dan pembatasan ukuran data harus dipatuhi agar instruksi valid \cite{hyde2010art}.

\section{Instruksi Perpindahan Data (MOV)}
\subsection{Sintaks dan aturan penggunaan}
Bentuk umum: \texttt{MOV destination, source} \cite{hyde2010art}. Aturan pokok: ukuran operand harus sama; perpindahan memori-ke-memori langsung tidak diperbolehkan (harus melalui register); beberapa register khusus (\texttt{CS}) tidak dapat ditulis langsung dengan \texttt{MOV} biasa \cite{susanto1995belajar}.

\subsubsection{Antar register}
\begin{verbatim}
mov ax, bx      ; salin BX -> AX (16-bit)
mov al, ah      ; salin AH -> AL (8-bit)
\end{verbatim}

\section{Pendalaman}\label{sec:aritmatika-pendalaman}
\subsection{Instruksi aritmatika tambahan}
Selain \texttt{ADD}/\texttt{SUB}/\texttt{MUL}/\texttt{DIV}, 8086 mendukung: \texttt{ADC}/\texttt{SBB} (operasi dengan carry/borrow untuk angka multi-word), \texttt{INC}/\texttt{DEC} (tanpa memengaruhi \texttt{CF}), \texttt{NEG} (dua komplemen), \texttt{CMP} (seperti \texttt{SUB} tanpa menyimpan hasil), serta \texttt{DAA}/\texttt{DAS}/\texttt{AAA}/\texttt{AAS} untuk penyesuaian BCD. \cite{intel2019manual32,rbil}

\subsection{Perluasan tanda dan pembagian aman}
Gunakan \texttt{CBW} (convert byte to word) untuk menandatangani \texttt{AL} ke \texttt{AX} sebelum \texttt{IDIV}/\texttt{IMUL} (pada 8086 hanya \texttt{MUL}/\texttt{DIV} tersedia; varian bertanda formal hadir pada generasi lebih baru namun konsep sign-extension tetap relevan). Untuk pembagian 16-bit, pastikan \texttt{DX} berisi bagian tinggi (0 untuk tak bertanda; sign-extension untuk bertanda). Cek penyebut nol untuk menghindari exception. \cite{intel2019manual32}

\subsection{Aritmatika multi-precision}
Untuk menjumlahkan dua bilangan 32-bit tersimpan sebagai \texttt{DX:AX} dan \texttt{BX:CX} (high:low), gunakan \texttt{ADD} pada low word lalu \texttt{ADC} pada high word:
\begin{verbatim}
add ax, cx   ; low
adc dx, bx   ; high + carry
\end{verbatim}

\subsection{Pemilihan cabang berdasarkan flags}
Untuk data tak bertanda gunakan \texttt{JA}/\texttt{JAE}/\texttt{JB}/\texttt{JBE} (berbasis \texttt{CF}/\texttt{ZF}); untuk bertanda gunakan \texttt{JG}/\texttt{JGE}/\texttt{JL}/\texttt{JLE} (berbasis \texttt{SF}/\texttt{OF}/\texttt{ZF}). Pastikan interpretasi konsisten dari sumber data. \cite{intel2019manual32}

\subsection{Kasus tepi umum}
\begin{itemize}
  \item Overflow bertanda: contoh \texttt{0x7FFF + 0x0001} menghasilkan \texttt{OF=1}, \texttt{CF=0}.
  \item Borrow tak bertanda: \texttt{SUB AX, BX} dengan \texttt{AX<BX} akan menyetel \texttt{CF=1}.
  \item \texttt{INC}/\texttt{DEC}: tidak mengubah \texttt{CF}; hati-hati untuk algoritma yang mengandalkan carry chain.
\end{itemize}

\subsubsection{Dari/ke memori}
\begin{verbatim}
mov ax, [si]        ; baca word dari DS:SI ke AX
mov [bx+4], dl      ; tulis byte DL ke DS:[BX+4]
\end{verbatim}

\subsubsection{Dengan konstanta}
\begin{verbatim}
mov ax, 1234h   ; immediate -> register
mov byte ptr [di], 0 ; immediate -> memori (byte)
\end{verbatim}

\subsubsection{Contoh dan praktik baik}
Gunakan \texttt{BYTE PTR}/\texttt{WORD PTR} untuk memperjelas ukuran operand bila ambigu. Pastikan segmen default (\texttt{DS} untuk data, \texttt{SS} untuk \texttt{BP}) dipahami saat mengakses memori.

\subsection{Operasi Aritmatika}
\subsubsection{ADD dan SUB}
\begin{verbatim}
mov ax, 5
add ax, 3      ; AX = 8, ZF=0, CF=0
sub ax, 10     ; AX = FFFEh (jika 16-bit), SF=1, mungkin CF=1
\end{verbatim}
\textbf{Catatan}: \texttt{ADD}/\texttt{SUB} memutakhirkan \texttt{CF}, \texttt{ZF}, \texttt{SF}, \texttt{OF}, \texttt{AF}, \texttt{PF} sesuai hasil.

\subsubsection{MUL dan DIV}
\texttt{MUL} dan \texttt{DIV} menggunakan register implisit \cite{hyde2010art}:\newline
\textbf{8-bit}: \texttt{MUL r/m8} -> \texttt{AX = AL * r/m8}; \texttt{DIV r/m8} -> \texttt{AL = AX / r/m8}, \texttt{AH = AX mod r/m8}.\newline
\textbf{16-bit}: \texttt{MUL r/m16} -> hasil di \texttt{DX:AX}; \texttt{DIV r/m16} -> \texttt{AX = DX:AX / r/m16}, sisa di \texttt{DX} \cite{susanto1995belajar}.
\begin{verbatim}
; Perkalian 16-bit
mov ax, 1234h
mov bx, 0002h
mul bx           ; DX:AX = AX * BX

; Pembagian 8-bit
mov ax, 0123h    ; AL=23h, AH=01h -> 0x0123 = 291 desimal
mov bl, 0Ah      ; 10 desimal
div bl           ; AL=29h (41 des), AH=01h (sisa 1)
\end{verbatim}
\textbf{Perhatian}: \texttt{DIV} memicu kesalahan pembagian jika penyebut 0 atau hasil tidak muat dalam register hasil.

\subsubsection{Penanganan overflow/underflow}
Pantau \texttt{OF}/\texttt{CF} setelah operasi. Gunakan percabangan untuk menangani kondisi luapan. Untuk operasi bertanda, gunakan instruksi khusus (mis. \texttt{IMUL}/\texttt{IDIV} pada prosesor yang mendukung) dan interpretasi \texttt{SF}/\texttt{OF}.

\subsection{Flag Register dan Operasi Aritmatika}
\begin{itemize}
  \item \textbf{CF (Carry)}: Menandakan carry keluar pada penjumlahan atau borrow pada pengurangan (aritmatika tak bertanda).
  \item \textbf{ZF (Zero)}: Hasil operasi bernilai nol.
  \item \textbf{SF (Sign)}: Bit tertinggi hasil (menunjukkan tanda pada interpretasi bertanda).
  \item \textbf{OF (Overflow)}: Luapan pada aritmatika bertanda (hasil tidak muat dalam rentang bertanda).
  \item \textbf{PF (Parity)}: Paritas bit rendah dari hasil (jumlah bit 1 genap).
  \item \textbf{AF (Auxiliary Carry)}: Carry dari bit 3 ke bit 4 (relevan untuk BCD).
\end{itemize}
\noindent\textbf{Contoh pemeriksaan flag}
\begin{verbatim}
add ax, bx
jo overflow_handler   ; jika overflow bertanda
jc carry_handler      ; jika carry (tak bertanda)
jz zero_handler       ; jika hasil nol
\end{verbatim}

\section{Contoh Soal dan Pembahasan}
\begin{enumerate}
  \item \textbf{Program perpindahan data antar register}.\\ Tunjukkan \texttt{MOV AX,BX}, \texttt{MOV CH,CL}, dan jelaskan ukuran operand.
  \item \textbf{Penjumlahan dua bilangan 16-bit}.\\ Baca dari memori ke register, \texttt{ADD}, simpan kembali. Bahas \texttt{CF}/\texttt{OF}.
  \item \textbf{Pengurangan dengan penanganan flag}.\\ Gunakan \texttt{SBB} bila ada carry sebelumnya; contohkan cabang jika \texttt{CF}=1.
  \item \textbf{Perkalian dan pembagian}.\\ Tunjukkan tata letak hasil \texttt{MUL} (\texttt{DX:AX}) dan \texttt{DIV} (hasil dan sisa).
  \item \textbf{Kalkulator sederhana}.\\ Rangka kerangka input satu digit dan operasi dasar; bahas validasi pembagian dengan nol.
\end{enumerate}

\section{Latihan}
\begin{enumerate}
  \item Buat program menghitung \((A+B) - (C+D)\) untuk empat bilangan 16-bit di memori. Laporkan \texttt{CF}/\texttt{OF}.
  \item Buat program menghitung \((X \times Y) / Z\) (8-bit), lengkapi pemeriksaan penyebut nol dan luapan hasil.
  \item Jelaskan secara tertulis bagaimana \texttt{CF}, \texttt{OF}, \texttt{ZF}, \texttt{SF} berubah pada masing-masing operasi contoh Anda.
  \item Buat program yang menampilkan status flag setelah \texttt{ADD} dan \texttt{SUB} menggunakan instruksi cabang bersyarat dan tulis hasil ke memori.
\end{enumerate}

\section{Praktikum}
\begin{enumerate}
  \item Implementasikan skenario perpindahan data antar register dan antara register-memori; verifikasi dengan debugger.
  \item Implementasikan penjumlahan/pengurangan 16-bit, amati \texttt{CF}/\texttt{OF} di debugger.
  \item Implementasikan \texttt{MUL}/\texttt{DIV} (8-bit dan 16-bit), catat tata letak hasil dan sisa.
  \item Susun \textit{mini-kalkulator} yang menerima dua operand kecil (hard-coded) dan memilih operasi melalui konstanta; tampilkan hasil via \texttt{INT 21h, AH=09h} (konversi numerik sederhana dapat berupa heksadesimal).
\end{enumerate}

\section{Contoh Kode}
\begin{verbatim}
; Program operasi aritmatika dasar
TITLE Operasi Aritmatika
.MODEL SMALL
.STACK 100h

.DATA
    bil1 DW 15
    bil2 DW 7
    hasil DW ?

.CODE
START:
    MOV AX, @DATA
    MOV DS, AX
    
    ; Penjumlahan
    MOV AX, bil1
    ADD AX, bil2
    MOV hasil, AX
    
    ; Pengurangan
    MOV AX, bil1
    SUB AX, bil2
    
    ; Perkalian (16-bit implisit: DX:AX = AX * bil2)
    MOV AX, bil1
    MOV BX, bil2
    MUL BX
    
    ; Pembagian (16-bit implisit: AX = DX:AX / BX, sisa di DX)
    XOR DX, DX
    MOV AX, bil1
    MOV BX, bil2
    ; Pastikan BX != 0 sebelum DIV
    OR BX, BX
    JZ done
    DIV BX

 done:
    MOV AH, 4Ch
    INT 21h
END START
\end{verbatim}

\section{Tugas}
\begin{itemize}
  \item \textbf{Kalkulator sederhana}: Implementasikan operasi \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} untuk operand 8-bit. Tampilkan hasil dalam heksadesimal; tangani pembagian nol.
  \item \textbf{Rata-rata 5 bilangan}: Baca lima nilai 8-bit dari memori, hitung jumlah 16-bit, bagi dengan 5 menggunakan \texttt{DIV} (perhatikan sisa), tampilkan hasil.
  \item \textbf{Dokumentasi flag}: Buat tabel eksperimen yang menunjukkan nilai \texttt{CF}, \texttt{OF}, \texttt{ZF}, \texttt{SF}, \texttt{PF}, \texttt{AF} untuk beberapa kombinasi operand; jelaskan anomali yang Anda amati.
\end{itemize}

\section{Referensi}
% Bibliography is handled by the main document
